/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* reverseList(struct ListNode* head)
{
    struct ListNode *prev = NULL, *curr = head, *nxt = NULL;
    
    while (curr != NULL) {
        nxt = curr->next;
        curr->next = prev;
        prev = curr;
        curr = nxt;
    }
    
    return prev;
}

struct ListNode* reverseKGroup(struct ListNode* head, int k)
{
    // return head if there is 0/1 element in the list 
    if (head == NULL || head->next == NULL)
        return head;
    
    struct ListNode *curr = head, *prev = head, *nxt = NULL;
    struct ListNode *lastTail = NULL, *retHead = NULL;
    struct ListNode *reverse = NULL;
    
    while (curr != NULL) {
        /*
		 * create a k-distance between the prev and curr node
		 * e.g: if k = 3: list 1[prev] -> 2 -> 3[curr] ->4->5-> NULL
		 * further we reverse the sub-list 1->2->3
		 */
        for (int i = 0; i < k - 1 && curr != NULL; i++)
            curr = curr->next;
        /*
         * if the curr has reached the end-point, 
         * then there aren't enough k-elements to
         * to reverse k-groups => Leaving the rest of
         * the list as it is
         */
        if (curr == NULL)
            return retHead;
        
        nxt = curr->next;
        curr->next = NULL;
        
        // reverse the elemnts in the k-group
        reverse = reverseList(prev);
        
        // keep track of the head node to be returned.
        if (retHead == NULL)
            retHead = reverse;
        
        // keep a track of the tail of the previously reversed k-group set
        if (lastTail != NULL)
            lastTail->next = reverse;
        lastTail = prev;
        
        // updating all pointers for the next set of k-group
        prev->next = nxt;
        curr = nxt;
        prev = curr;
    }
    
    return retHead;
}
